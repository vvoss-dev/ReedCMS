rule_id|category|rule|rationale|example_good|example_bad|severity|ticket_ref|decision_pattern
CS-001|imports|Import only what you use - no precautionary imports|Unused imports create noise and hide actual dependencies. Remove unused imports immediately.|use std::collections::HashMap; // Used in line 45|use std::collections::{HashMap, BTreeMap}; // BTreeMap never used|warning|REED-90-03|REMOVE: Delete unused imports
CS-002|imports|Implementation details stay in their module - do not expose|Public APIs should only expose what consumers need. Internal types stay internal.|use super::resolver::DependencyResolver; // Public API|use super::resolver::{DependencyResolver, Module}; // Module is internal|warning|REED-90-03|REMOVE: Import only public API types
CS-003|imports|Stringent but unused code gets commented out with justification|Code that logically belongs (stringent/consistent with architecture) but has no current use stays as commented code with explanation. This preserves design intent without triggering warnings.|// NOTE: HashMap import stringent for cache operations but not yet used\n// Uncomment when implementing direct cache access (REED-10-XX)\n// use std::collections::HashMap;|use std::collections::HashMap; // Unused - triggers warning|info|REED-90-03|COMMENT: Keep design intent visible
CS-004|imports|If keeping unused import for future use, suppress with ticket reference|Future-oriented code needs explicit justification with ticket reference to distinguish from forgotten code.|// ALLOW: unused_imports - Reserved for plugin API (REED-11-01)\n#[allow(unused_imports)]\nuse crate::plugin::Module;|#[allow(unused_imports)]\nuse something; // No explanation|warning|REED-90-03|SUPPRESS: Document WHY and WHEN
CS-005|refactoring|Remove orphaned imports after refactoring|When refactoring code (e.g., changing from Singleton to per-request pattern), clean up all related imports immediately. Old imports are not stringent - they are refactoring debt.|// After refactoring to per-request pattern:\nuse minijinja::Environment; // Only in local scope where used|// Top-level singleton imports left behind:\nuse minijinja::Environment;\nuse std::sync::OnceLock; // No longer used|error|REED-90-03|REMOVE: Refactoring cleanup mandatory
CS-006|ownership|Understand Rust references: never clone a reference|.clone() on a reference clones the reference pointer, not the data. This is almost always wrong. Clone the value before taking a reference, or just use the reference.|for item in iterator(&data) { }|for item in iterator(&data.clone()) { } // Clones pointer, not data!|error|REED-90-03|REMOVE: Use reference directly
