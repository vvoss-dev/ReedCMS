rule_id|category|rule|rationale|example_good|example_bad|severity|ticket_ref|decision_pattern
CS-001|imports|Import only what you use - no precautionary imports|Unused imports create noise and hide actual dependencies. Remove unused imports immediately.|use std::collections::HashMap; // Used in line 45|use std::collections::{HashMap, BTreeMap}; // BTreeMap never used|warning|REED-90-03|REMOVE: Delete unused imports
CS-002|imports|Implementation details stay in their module - do not expose|Public APIs should only expose what consumers need. Internal types stay internal.|use super::resolver::DependencyResolver; // Public API|use super::resolver::{DependencyResolver, Module}; // Module is internal|warning|REED-90-03|REMOVE: Import only public API types
CS-003|imports|Stringent but unused code gets commented out with justification|Code that logically belongs (stringent/consistent with architecture) but has no current use stays as commented code with explanation. This preserves design intent without triggering warnings.|// NOTE: HashMap import stringent for cache operations but not yet used\n// Uncomment when implementing direct cache access (REED-10-XX)\n// use std::collections::HashMap;|use std::collections::HashMap; // Unused - triggers warning|info|REED-90-03|COMMENT: Keep design intent visible
CS-004|imports|If keeping unused import for future use, suppress with ticket reference|Future-oriented code needs explicit justification with ticket reference to distinguish from forgotten code.|// ALLOW: unused_imports - Reserved for plugin API (REED-11-01)\n#[allow(unused_imports)]\nuse crate::plugin::Module;|#[allow(unused_imports)]\nuse something; // No explanation|warning|REED-90-03|SUPPRESS: Document WHY and WHEN
CS-005|refactoring|Remove orphaned imports after refactoring|When refactoring code (e.g., changing from Singleton to per-request pattern), clean up all related imports immediately. Old imports are not stringent - they are refactoring debt.|// After refactoring to per-request pattern:\nuse minijinja::Environment; // Only in local scope where used|// Top-level singleton imports left behind:\nuse minijinja::Environment;\nuse std::sync::OnceLock; // No longer used|error|REED-90-03|REMOVE: Refactoring cleanup mandatory
CS-006|ownership|Understand Rust references: never clone a reference|.clone() on a reference clones the reference pointer, not the data. This is almost always wrong. Clone the value before taking a reference, or just use the reference.|for item in iterator(&data) { }|for item in iterator(&data.clone()) { } // Clones pointer, not data!|error|REED-90-03|REMOVE: Use reference directly
CS-007|iterators|Use .flatten() for Result unwrapping in iterators|When iterating over Results and only processing Ok values, use .flatten() instead of nested if let. More idiomatic and cleaner.|for entry in entries.flatten() { }|for entry in entries { if let Ok(entry) = entry { } }|warning|REED-90-03|USE: Apply .flatten() to iterator
CS-008|traits|Implement FromStr trait instead of custom from_str methods|Custom from_str() methods should implement the FromStr trait for idiomatic string parsing. Enables .parse() method and trait bounds.|impl FromStr for Type { type Err = ReedError; fn from_str(s: &str) -> Result<Self, ReedError> { } }\nlet val = "text".parse::<Type>()?;|impl Type { pub fn from_str(s: &str) -> ReedResult<Self> { } }\nlet val = Type::from_str("text")?;|warning|REED-90-03|IMPLEMENT: Use standard FromStr trait
CS-009|patterns|Use default wildcard pattern _ instead of redundant "value" \| _|In match expressions, "value" \| _ is redundant because _ already matches everything including "value". Use _ alone for default cases.|match format { "json" => json(), _ => default() }|match format { "json" => json(), "table" \| _ => default() }|warning|REED-90-03|SIMPLIFY: Remove redundant pattern from wildcard
CS-010|collections|Use .to_vec() instead of .iter().cloned().collect() on slices|When cloning a slice into a Vec, .to_vec() is faster and more readable than .iter().cloned().collect(). Optimized for this specific use case.|let copy = slice.to_vec();|let copy = slice.iter().cloned().collect::<Vec<_>>();|warning|REED-90-03|OPTIMIZE: Use .to_vec() for slice cloning
CS-011|patterns|Collapse nested Option matches into single pattern|When matching Option<Option<T>>, use if let Some(Some(x)) instead of nested if let. More idiomatic and reduces indentation.|if let Some(Some(val)) = opt_opt { use(val); }|if let Some(opt) = opt_opt { if let Some(val) = opt { use(val); } }|warning|REED-90-03|COLLAPSE: Use nested pattern matching
CS-012|collections|Use .first() instead of .get(0) for slice access|For accessing the first element of a slice, .first() is more idiomatic and clearer than .get(0).|let first = args.first();|let first = args.get(0);|warning|REED-90-03|USE: Apply .first() method
CS-013|traits|Use #[derive(Default)] instead of manual impl when possible|If Default implementation just creates zero/empty values, use #[derive(Default)] to generate it automatically. Less code, same functionality.|#[derive(Debug, Clone, Default)]\nstruct Metrics { count: u64 }|#[derive(Debug, Clone)]\nstruct Metrics { count: u64 }\nimpl Default for Metrics { fn default() -> Self { Self { count: 0 } } }|warning|REED-90-03|DERIVE: Use automatic Default generation
CS-014|collections|Use .or_default() instead of .or_insert_with(T::new)|When inserting default values into HashMap/BTreeMap, .or_default() is clearer and shorter than .or_insert_with(Vec::new) or .or_insert_with(HashMap::new).|map.entry(key).or_default().push(val);|map.entry(key).or_insert_with(Vec::new).push(val);|warning|REED-90-03|SIMPLIFY: Use or_default() for default insertions
CS-015|strings|Use .strip_prefix()/.strip_suffix() instead of manual slicing|String prefix/suffix removal should use strip_prefix()/strip_suffix() instead of manual slice indexing. Safer and clearer.|if let Some(rest) = s.strip_prefix("--") { }|if s.starts_with("--") { let rest = &s[2..]; }|warning|REED-90-03|USE: Apply strip_prefix/suffix methods
CS-016|operators|Remove useless question mark operator|If function returns Result and last line is Ok(expr?), simplify to just expr since both return the same Result type.|fn f() -> Result<T> { some_result() }|fn f() -> Result<T> { Ok(some_result()?) }|warning|REED-90-03|REMOVE: Unnecessary Ok wrapping
CS-017|ownership|Remove unnecessary reference creation|Don't create references that are immediately dereferenced by the compiler. Pass values directly when the function accepts both.|regex.captures_iter(text)|regex.captures_iter(&text) // &String when &str expected|warning|REED-90-03|REMOVE: Unnecessary reference operator
CS-018|strings|Remove .trim() before .split_whitespace()|.split_whitespace() already handles leading/trailing whitespace, so .trim() before it is redundant.|text.split_whitespace()|text.trim().split_whitespace()|warning|REED-90-03|REMOVE: Redundant trim call
CS-019|iterators|Use .next_back() instead of .last() on DoubleEndedIterator|For DoubleEndedIterator, .next_back() is O(1) while .last() unnecessarily iterates entire iterator to find last element.|addr.split(':').next_back()|addr.split(':').last() // Iterates all elements!|warning|REED-90-03|OPTIMIZE: Use next_back() for efficiency
CS-020|collections|Remove .enumerate() if index is not used|If you use .enumerate() but immediately discard the index with _, remove .enumerate() entirely for clarity.|for line in reader.lines() { }|for (_idx, line) in reader.lines().enumerate() { }|warning|REED-90-03|REMOVE: Unnecessary enumerate call
CS-021|collections|Use .is_empty() instead of .len() >= 1 or == 0|Checking if collection is empty should use .is_empty() instead of length comparisons. More idiomatic and clearer intent.|if !vec.is_empty() { }|if vec.len() >= 1 { }|warning|REED-90-03|USE: Apply is_empty() method
